from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models.item import Item
from sqlalchemy import func
from app import db

bp = Blueprint('analytics', __name__, url_prefix='/api/analytics')

@bp.route('/stats', methods=['GET'])
@jwt_required()
def get_stats():
    user_id = get_jwt_identity()
    
    # 总体统计
    total = Item.query.filter_by(author_id=user_id).count()
    answered = Item.query.filter_by(author_id=user_id).filter(
        Item.status.in_(['ANSWERED', 'MASTERED'])
    ).count()
    mastered = Item.query.filter_by(author_id=user_id, status='MASTERED').count()
    need_review = Item.query.filter_by(author_id=user_id, status='NEED_REVIEW').count()
    
    # 按科目统计 - 使用数据库中的大写枚举值
    by_subject = {}
    subjects = ['READING', 'WRITING', 'MATHS', 'THINKING_SKILLS']
    for subject in subjects:
        subject_total = Item.query.filter_by(author_id=user_id, subject=subject).count()
        subject_answered = Item.query.filter_by(author_id=user_id, subject=subject).filter(
            Item.status.in_(['ANSWERED', 'MASTERED'])
        ).count()
        subject_mastered = Item.query.filter_by(author_id=user_id, subject=subject, status='MASTERED').count()
        by_subject[subject] = {
            'total': subject_total,
            'answered': subject_answered,
            'mastered': subject_mastered
        }
        
    # 按集合统计 (New)
    from app.models.collection import Collection
    from sqlalchemy import case
    
    # Get all active collections
    collections = Collection.query.filter_by(user_id=user_id, is_deleted=False).all()
    collection_map = {c.id: c for c in collections}
    
    # Initialize result structure
    by_collection = {
        c.id: {
            'name': c.name,
            'total': 0,
            'answered': 0,
            'mastered': 0,
            'color': c.color,
            'icon': c.icon
        } for c in collections
    }
    
    if collections:
        # Aggregate stats in a single query
        stats = db.session.query(
            Item.collection_id,
            func.count(Item.id).label('total'),
            func.sum(case((Item.status.in_(['ANSWERED', 'MASTERED']), 1), else_=0)).label('answered'),
            func.sum(case((Item.status == 'MASTERED', 1), else_=0)).label('mastered')
        ).filter(
            Item.author_id == user_id,
            Item.collection_id.in_(collection_map.keys())
        ).group_by(Item.collection_id).all()
        
        # Populate stats
        for stat in stats:
            if stat.collection_id in by_collection:
                by_collection[stat.collection_id]['total'] = stat.total
                by_collection[stat.collection_id]['answered'] = int(stat.answered or 0)
                by_collection[stat.collection_id]['mastered'] = int(stat.mastered or 0)
    
    # 按难度统计
    by_difficulty = {}
    for i in range(1, 6):
        count = Item.query.filter_by(author_id=user_id, difficulty=i).count()
        by_difficulty[str(i)] = count
    
    return jsonify({
        'total_questions': total,
        'answered_questions': answered,
        'mastered_questions': mastered,
        'need_review_questions': need_review,
        'by_subject': by_subject,
        'by_collection': by_collection,
        'by_difficulty': by_difficulty
    }), 200


@bp.route('/recommendations', methods=['GET'])
@jwt_required()
def get_recommendations():
    user_id = get_jwt_identity()
    limit = request.args.get('limit', 10, type=int)
    subject = request.args.get('subject')
    collection_id = request.args.get('collection_id', type=int)
    
    # 简化推荐逻辑(Week 5会完善)
    query = Item.query.filter_by(author_id=user_id)
    
    if subject:
        query = query.filter_by(subject=subject)
        
    if collection_id:
        query = query.filter_by(collection_id=collection_id)
    
    # 优先级: NEED_REVIEW > UNANSWERED, 按难度升序
    need_review = query.filter_by(status='NEED_REVIEW').order_by(Item.difficulty.asc()).limit(limit).all()
    
    if len(need_review) < limit:
        remaining = limit - len(need_review)
        unanswered = query.filter_by(status='UNANSWERED').order_by(Item.difficulty.asc()).limit(remaining).all()
        recommendations = need_review + unanswered
    else:
        recommendations = need_review
    
    from app.schemas.item import ItemSchema
    schema = ItemSchema(many=True)
    return jsonify(schema.dump(recommendations)), 200

